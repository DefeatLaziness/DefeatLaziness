---
title: 算法-链表
date: 2022-07-19 16:08:03
summary: 算法-链表
tags: [算法]
categories: [算法]
---

# 链表

## 理解链表

带有封装性质的数据结构，两块东西，数据和引用(指针)

## 链表的特点

1. 空间上不连续
2. 每存放一个值都会有一个引用空间

## 优点

1. 只要内存足够大，就能存的下，不用担心空间碎片的问题
2. 链表添加和删除非常容易

## 缺点

1. 链表的查询速度慢

2. 链表的每一个查询都需要创建一个next，直接double了空间(在引用值和传的值相等的情况下double空间)

   ### 缺点避免

   1. 节点内多开销的数存的越多，对内存影响越少

## 延伸（重要）

1. 传递一个链表，必须传递链表对根节点
2. 每一个节点都认为自己是根节点



## 循环遍历数组和链表

```tsx
// 循环遍历数组
let a = [1,2,3,4,5]

function traverse(arr: number[]) {
    if (arr === null) return
    for (let index = 0; index < arr.length; index++) {
        console.log(arr[index]);
        
    }
}

traverse(a)
// 1
// 2
// 3
// 4
// 5

// 循环遍历链表
class CreateNode {
    next: CreateNode | null

    constructor(public value: number) {
        this.value = value
        this.next = null
    }
}

let a = new CreateNode(1)
let b = new CreateNode(2)
let c = new CreateNode(3)
let d = new CreateNode(4)

a.next = b
b.next = c
c.next = d

function traverse(root: CreateNode) {
    let temp = root
    while(temp != null) {
        console.log(temp.value);
        temp = temp.next!
        console.log(temp);
        
    }
}

traverse(a)
// 1
// 2
// 3
// 4
```



## 递归遍历数组和链表

```tsx
// 递归遍历数组
let arr = [1,2,3,4,5]

function traverse(arr: any[], index = 0) {
    if (arr === null || index >= arr.length) return
    console.log(arr[index]);
    traverse(arr, index + 1)
}

traverse(arr)
// 1
// 2
// 3
// 4
// 5

// 递归遍历链表
class CreateNode {
    next: CreateNode | null

    constructor(public value: number) {
        this.value = value
        this.next = null
    }
}

let a = new CreateNode(1)
let b = new CreateNode(2)
let c = new CreateNode(3)
let d = new CreateNode(4)

a.next = b
b.next = c
c.next = d

function traverse(root: CreateNode) {
    if (root === null) return
    console.log(root.value);
    traverse(root.next!)
}

traverse(a)
// 1
// 2
// 3
// 4
```

